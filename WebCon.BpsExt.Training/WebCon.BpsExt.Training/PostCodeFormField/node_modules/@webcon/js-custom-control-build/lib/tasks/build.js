const babel = require('rollup-plugin-babel');
const commonJS = require('rollup-plugin-commonjs');
const css = require('rollup-plugin-css-only');
const replace = require('rollup-plugin-replace');
const fs = require('fs');
const imageType = require('image-type');
const path = require('path');
const readChunk = require('read-chunk');
const resolve = require('rollup-plugin-node-resolve');
const rollup = require('rollup');
const sanitize = require('sanitize-filename');
const sass = require('node-sass');
const zip = require('gulp-zip');
const { distPath, packagePath, manifestPath } = require('./const');

function build(gulp) {
    return async function build() {
        if (!fs.existsSync(distPath)) fs.mkdirSync(distPath);

        const { packageName, solutionId, ...manifest } = getManifest();

        await processSingleEntry(
            'component',
            solutionId,
            [
                css({
                    output: styles =>
                        fs.writeFileSync(
                            `${distPath}/bundle.css`,
                            wrapWithBaseClass(
                                styles,
                                replaceSolutionId(solutionId)
                            )
                        ),
                }),
            ],
            false
        );
        await processSingleEntry('emptyValueValidator', solutionId);
        await processSingleEntry('additionalValidator', solutionId);

        copyAssets(manifest);
        copyManifest();

        return gulp
            .src(`${distPath}/**/*`)
            .pipe(zip(`${sanitize(packageName)}.bpspkg`))
            .pipe(gulp.dest(packagePath));
    };
}

function copyAssets(manifest) {
    const assets = manifest.files.assets;

    if (typeof assets !== 'object') {
        return;
    }

    const assetsPath = `${distPath}/assets`;
    const keys = Object.keys(assets);
    const filesToCopy = keys.map(n => ({ key: n, path: assets[n] }));

    if (!fs.existsSync(assetsPath)) fs.mkdirSync(assetsPath);

    for (let i = 0; i < filesToCopy.length; i++) {
        const file = filesToCopy[i];

        if (!fs.existsSync(file.path)) {
            throw Error(`Asset file '${file.key}' does not exist.`);
        }

        const chunk = readChunk.sync(file.path, 0, imageType.minimumBytes);
        const isImage = imageType(chunk);

        if (!isImage) {
            throw Error(`Asset file '${file.key}' is not an image file.`);
        }

        const ext = path.extname(file.path);

        fs.copyFileSync(file.path, `${assetsPath}/${file.key}${ext}`);
    }
}

function copyManifest() {
    fs.copyFileSync(manifestPath, `${distPath}/manifest.json`);
}

function getManifest() {
    const manifestBuffer = fs.readFileSync(manifestPath);
    const manifest = JSON.parse(manifestBuffer);

    return manifest;
}

function getPath(type, optional = true) {
    const manifest = getManifest();

    if (typeof manifest.files !== 'object') {
        throw Error('Invalid manifest file.');
    }

    const path = manifest.files[type];

    if (optional && path === undefined) {
        return null;
    }

    if (path === undefined || !fs.existsSync(path)) {
        throw Error(`File '${path}' for '${type}' file type does not exist.`);
    }

    return path;
}

function replaceSolutionId(solutionId) {
    return solutionId.replace(/-/g, '_');
}

async function processSingleEntry(
    type,
    solutionId,
    plugins = [],
    optional = true
) {
    const path = getPath(type, optional);

    if (!path) {
        return;
    }

    const component = await rollup.rollup({
        context: 'window',
        external: ['react'],
        input: path,
        plugins: [
            resolve(),
            replace({
                'process.env.NODE_ENV': JSON.stringify('development'),
            }),
            ...plugins,
            babel({
                exclude: 'node_modules/**',
                plugins: [require('@babel/plugin-proposal-class-properties')],
                presets: [
                    [
                        require('@babel/preset-env'),
                        {
                            corejs: { version: 3, proposals: true },
                            modules: false,
                            useBuiltIns: 'usage',
                        },
                    ],
                    [
                        require('@babel/preset-react'),
                        {
                            pragma: 'webcon.createElement',
                        },
                    ],
                ],
            }),
            commonJS({
                include: 'node_modules/**',
            }),
        ],
    });

    const solutionIdWithDashes = replaceSolutionId(solutionId);

    await component.write({
        file: `${distPath}/${type}.js`,
        format: 'iife',
        footer: () => {
            return `window.webcon = window.webcon || {};
window.webcon.customControls = window.webcon.customControls || {};
window.webcon.customControls.${type}s = window.webcon.customControls.${type}s || {};
window.webcon.customControls.${type}s['${solutionId}'] = ${type}_${solutionIdWithDashes};`;
        },
        globals: {
            react: 'React',
        },
        name: `${type}_${solutionIdWithDashes}`, // `window.webcon.customControls.${type}s.${solutionId}`,
        sourcemap: false,
    });
}

function wrapWithBaseClass(styles, solutionId) {
    return sass.renderSync({
        data: `.dynamic-form .component_${solutionId} {
    ${styles}
}`,
    }).css;
}

exports.build = build;
